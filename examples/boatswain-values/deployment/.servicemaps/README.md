

# Service Maps
**(Note: Currently service maps are only supported for `boatswain stage push`, and `.servicemaps/staging.yaml` is hardcoded. This is okay for now.)**

Service maps offer the ability to deploy groups of applications together, with wiring between those applications defined based on the specific needs of what needs to be tested. The functionality leans heavily on the use of service prefixes. For instance, deploying `boatswain stage push hydra my-test` will produce a pod and service in the cluster prefixed with `my-test`:
```
> kubectl get pod
NAME                                         READY     STATUS    RESTARTS   AGE
my-test-hydra-229737899-hhmkf                1/1       Running   0          1h
staging-hydra-999937899-abecd                1/1       Running   0          8d
```

```
> kubectl get svc
NAME                         CLUSTER-IP   EXTERNAL-IP        PORT(S)             AGE
my-test-hydra                10.3.0.22    <none>             80/TCP              18h
staging-hydra                10.3.0.181   <none>             3306/TCP            18h
```

Note that there is a separate `staging-hydra` pod and service that lives in the cluster. This is the default hydra service that all other stagings will use unless otherwise defined in the `ServiceMap` object's `Test` array. In other words, the `staging-` prefix is the default prefix. By using service/pod prefixes, we can control the wiring of our staging deployments and customize service mapping based on what needs to be tested.

Let's use the following service map to describe a use case for deploying the `hydra` application to staging.

```yaml
Ingress: 
  Template: {{ .PackageID }}.staging.my-domain.com
  Service: medbridge
  Port: 80
ServiceMaps:
  - Name: hydra
    Test:
      - hydra
    Staging:
      - hydra-db
      - some-other-service
  - Name: hydra-db
    CloudFormationTemplate: ebs-hydra-mysql
    Test:
      - hydra
      - hydra-db
    Staging:
      - some-other-service
```

In the above example, we have two `ServiceMap` objects: `hydra` and `hydra-db`. The service map `hydra-db` offers a separate `hydra-db` service because there are oftentimes changes to `hydra` that involve destructive migrations to the database, and we want to be able to deploy hydra to staging with its own mysql instance in those cases. When you deploy the `hydra-db` service map you will get two pods: `hydra` and `hydra-db`. Let's say you run `boatswain stage push hydra-db my-test`. The two pods will look like this in the cluster:

```
> kubectl get pod
NAME                                         READY     STATUS    RESTARTS   AGE
my-test-hydra-229737899-hhmkf                1/1       Running   0          1h
my-test-hydra-db-238100249-vgr91             1/1       Running   0          1h
staging-hydra-db-999937899-abecd             1/1       Running   0          8d
```

The `my-test` hydra instance will communicate with the hydra-db pod using the `my-test` prefix, ignoring the existence of the `staging-hydra-db` instance. The pods know to do this based on the autogenerated values files. For instance, `hydra` autogenerated values file will look like this:

```yaml
Boatswain:
  ImageTag: "7549a18"
  ServiceEnv:
    HYDRA_DB_HOST: my-test-hydra-db
    OTHER_SERVICE_HOST: staging-other-service
```
