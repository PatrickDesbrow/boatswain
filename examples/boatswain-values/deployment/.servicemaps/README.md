

# Service Maps
**(Note: Currently service maps are only supported for `boatswain stage push`, and `.servicemaps/staging.yaml` is hardcoded. This is okay for now.)**

## Use Case

Service maps offer the ability to deploy groups of applications together, with wiring between those applications defined based on the specific needs of what needs to be tested. The functionality leans heavily on the use of service prefixes. For instance, deploying `boatswain stage push hydra my-test` will produce a pod and service in the cluster prefixed with `my-test`:
```
> kubectl get pod
NAME                                         READY     STATUS    RESTARTS   AGE
my-test-hydra-229737899-hhmkf                1/1       Running   0          1h
staging-hydra-999937899-abecd                1/1       Running   0          8d
```

```
> kubectl get svc
NAME                         CLUSTER-IP   EXTERNAL-IP        PORT(S)             AGE
my-test-hydra                10.3.0.22    <none>             80/TCP              18h
staging-hydra                10.3.0.181   <none>             3306/TCP            18h
```

Note that there is a separate `staging-hydra` pod and service that lives in the cluster. This is the default hydra service that all other stagings will use unless otherwise defined in the `ServiceMap` object's `Test` array. In other words, the `staging-` prefix is the default prefix.

Let's use the following service map to describe a use case for deploying the `hydra` application to staging.

```yaml
Ingress: 
  Template: {{ .PackageID }}.staging.my-domain.com
  Service: medbridge
  Port: 80
ServiceMaps:
  - Name: hydra
    Test:
      - hydra
    Staging:
      - hydra-db
      - some-other-service
  - Name: hydra-db
    CloudFormationTemplate: ebs-hydra-mysql
    Test:
      - hydra
      - hydra-db
    Staging:
      - some-other-service
```

The `Test` array is a list of the services that need to communicate with one another. The `Staging` array is a list of default services that need to be available to the deployment. In other words, these services will be made available with the `staging` prefix in the autogenerated values file.

In the above example, we have two `ServiceMap` objects: `hydra` and `hydra-db`. The service map `hydra-db` offers a separate `hydra-db` service because there are oftentimes changes to `hydra` that involve destructive migrations to the database, and we want to be able to deploy hydra to staging with its own mysql instance in those cases. When you deploy the `hydra-db` service map you will get two pods: `hydra` and `hydra-db`. Let's say you run `boatswain stage push hydra-db my-test`. The two pods will look like this in the cluster:

```
> kubectl get pod
NAME                                         READY     STATUS    RESTARTS   AGE
my-test-hydra-229737899-hhmkf                1/1       Running   0          1h
my-test-hydra-db-238100249-vgr91             1/1       Running   0          1h
staging-hydra-db-999937899-abecd             1/1       Running   0          8d
```

The `my-test` hydra instance will communicate with the hydra-db pod using the `my-test` prefix, ignoring the existence of the `staging-hydra-db` instance. The pods know to do this based on the autogenerated values files. For instance, `hydra` autogenerated values file will look like this:

```yaml
Boatswain:
  ImageTag: "7549a18"
  ServiceEnv:
    HYDRA_DB_HOST: my-test-hydra-db
    OTHER_SERVICE_HOST: staging-other-service
```

## CloudFormationTemplate

Notice in the example service map above, `hydra-db` has a `CloudFormationTemplate: ebs-hydra-mysql` key-value pair. When `hydra-db` is deployed, it needs to know how to create its separate mysql instance. This is where CloudFormation comes in handy. With a CloudFormation template, we can tell boatswain to provision an EBS volume generated from an existing hydra-db snapshot.
